// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: nyct-subway.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct TripReplacementPeriod {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The replacement period is for this route
  var routeID: String {
    get {return _storage._routeID ?? String()}
    set {_uniqueStorage()._routeID = newValue}
  }
  /// Returns true if `routeID` has been explicitly set.
  var hasRouteID: Bool {return _storage._routeID != nil}
  /// Clears the value of `routeID`. Subsequent reads from it will return its default value.
  mutating func clearRouteID() {_storage._routeID = nil}

  /// The start time is omitted, the end time is currently now + 30 minutes for
  ///
  /// all routes of the A division
  var replacementPeriod: TransitRealtime_TimeRange {
    get {return _storage._replacementPeriod ?? TransitRealtime_TimeRange()}
    set {_uniqueStorage()._replacementPeriod = newValue}
  }
  /// Returns true if `replacementPeriod` has been explicitly set.
  var hasReplacementPeriod: Bool {return _storage._replacementPeriod != nil}
  /// Clears the value of `replacementPeriod`. Subsequent reads from it will return its default value.
  mutating func clearReplacementPeriod() {_storage._replacementPeriod = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NYCT Subway extensions for the feed header
struct NyctFeedHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of the NYCT Subway extensions
  ///
  /// The current version is 1.0
  var nyctSubwayVersion: String {
    get {return _nyctSubwayVersion ?? String()}
    set {_nyctSubwayVersion = newValue}
  }
  /// Returns true if `nyctSubwayVersion` has been explicitly set.
  var hasNyctSubwayVersion: Bool {return self._nyctSubwayVersion != nil}
  /// Clears the value of `nyctSubwayVersion`. Subsequent reads from it will return its default value.
  mutating func clearNyctSubwayVersion() {self._nyctSubwayVersion = nil}

  /// For the NYCT Subway, the GTFS-realtime feed replaces any scheduled
  ///
  /// trip within the trip_replacement_period. 
  ///
  /// This feed is a full dataset, it contains all trips starting 
  ///
  /// in the trip_replacement_period. If a trip from the static GTFS is not
  ///
  /// found in the GTFS-realtime feed, it should be considered as cancelled.
  ///
  /// The replacement period can be different for each route, so here is 
  ///
  /// a list of the routes where the trips in the feed replace all 
  ///
  /// scheduled trips within the replacement period.
  var tripReplacementPeriod: [TripReplacementPeriod] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nyctSubwayVersion: String? = nil
}

/// NYCT Subway extensions for the trip descriptor
struct NyctTripDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The nyct_train_id is meant for internal use only. It provides an
  ///
  /// easy way to associated GTFS-realtime trip identifiers with NYCT rail
  ///
  /// operations identifier 
  ///
  /// 
  ///
  /// The ATS office system assigns unique train identification (Train ID) to
  ///
  /// each train operating within or ready to enter the mainline of the
  ///
  /// monitored territory. An example of this is 06 0123+ PEL/BBR and is decoded
  ///
  /// as follows: 
  ///
  /// 
  ///
  /// The first character represents the trip type designator. 0 identifies a
  ///
  /// scheduled revenue trip. Other revenue trip values that are a result of a
  ///
  /// change to the base schedule include; [= reroute], [/ skip stop], [$ turn
  ///
  /// train] also known as shortly lined service.  
  ///
  /// 
  ///
  /// The second character 6 represents the trip line i.e. number 6 train The
  ///
  /// third set of characters identify the decoded origin time. The last
  ///
  /// character may be blank "on the whole minute" or + "30 seconds" 
  ///
  /// 
  ///
  /// Note: Origin times will not change when there is a trip type change.  This
  ///
  /// is followed by a three character "Origin Location" / "Destination
  ///
  /// Location"
  var trainID: String {
    get {return _trainID ?? String()}
    set {_trainID = newValue}
  }
  /// Returns true if `trainID` has been explicitly set.
  var hasTrainID: Bool {return self._trainID != nil}
  /// Clears the value of `trainID`. Subsequent reads from it will return its default value.
  mutating func clearTrainID() {self._trainID = nil}

  /// This trip has been assigned to a physical train. If true, this trip is
  ///
  /// already underway or most likely will depart shortly. 
  ///
  ///
  ///
  /// Train Assignment is a function of the Automatic Train Supervision (ATS)
  ///
  /// office system used by NYCT Rail Operations to monitor and track train
  ///
  /// movements. ATS provides the ability to "assign" the nyct_train_id
  ///
  /// attribute when a physical train is at its origin terminal. These assigned
  ///
  /// trips have the is_assigned field set in the TripDescriptor.
  ///
  ///
  ///
  /// When a train is at a terminal but has not been given a work program it is
  ///
  /// declared unassigned and is tagged as such. Unassigned trains can be moved
  ///
  /// to a storage location or assigned a nyct_train_id when a determination for
  ///
  /// service is made.
  var isAssigned: Bool {
    get {return _isAssigned ?? false}
    set {_isAssigned = newValue}
  }
  /// Returns true if `isAssigned` has been explicitly set.
  var hasIsAssigned: Bool {return self._isAssigned != nil}
  /// Clears the value of `isAssigned`. Subsequent reads from it will return its default value.
  mutating func clearIsAssigned() {self._isAssigned = nil}

  /// Uptown and Bronx-bound trains are moving NORTH.
  ///
  /// Times Square Shuttle to Grand Central is also northbound.
  ///
  ///
  ///
  /// Downtown and Brooklyn-bound trains are moving SOUTH.
  ///
  /// Times Square Shuttle to Times Square is also southbound.
  ///
  /// 
  ///
  /// EAST and WEST are not used currently.
  var direction: NyctTripDescriptor.Direction {
    get {return _direction ?? .north}
    set {_direction = newValue}
  }
  /// Returns true if `direction` has been explicitly set.
  var hasDirection: Bool {return self._direction != nil}
  /// Clears the value of `direction`. Subsequent reads from it will return its default value.
  mutating func clearDirection() {self._direction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The direction the train is moving. 
  enum Direction: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case north // = 1
    case east // = 2
    case south // = 3
    case west // = 4

    init() {
      self = .north
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .north
      case 2: self = .east
      case 3: self = .south
      case 4: self = .west
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .north: return 1
      case .east: return 2
      case .south: return 3
      case .west: return 4
      }
    }

  }

  init() {}

  fileprivate var _trainID: String? = nil
  fileprivate var _isAssigned: Bool? = nil
  fileprivate var _direction: NyctTripDescriptor.Direction? = nil
}

/// NYCT Subway extensions for the stop time update
struct NyctStopTimeUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Provides the planned station arrival track. The following is the Manhattan
  ///
  /// track configurations:
  ///
  /// 1: southbound local
  ///
  /// 2: southbound express
  ///
  /// 3: northbound express
  ///
  /// 4: northbound local
  ///
  ///
  ///
  /// In the Bronx (except Dyre Ave line)
  ///
  /// M: bi-directional express (in the AM express to Manhattan, in the PM
  ///
  /// express away).
  ///
  ///
  ///
  /// The Dyre Ave line is configured:
  ///
  /// 1: southbound
  ///
  /// 2: northbound
  ///
  /// 3: bi-directional
  var scheduledTrack: String {
    get {return _scheduledTrack ?? String()}
    set {_scheduledTrack = newValue}
  }
  /// Returns true if `scheduledTrack` has been explicitly set.
  var hasScheduledTrack: Bool {return self._scheduledTrack != nil}
  /// Clears the value of `scheduledTrack`. Subsequent reads from it will return its default value.
  mutating func clearScheduledTrack() {self._scheduledTrack = nil}

  /// This is the actual track that the train is operating on and can be used to
  ///
  /// determine if a train is operating according to its current schedule
  ///
  /// (plan).
  ///
  /// 
  ///
  /// The actual track is known only shortly before the train reaches a station,
  ///
  /// typically not before it leaves the previous station. Therefore, the NYCT
  ///
  /// feed sets this field only for the first station of the remaining trip.
  ///
  /// 
  ///
  /// Different actual and scheduled track is the result of manually rerouting a
  ///
  /// train off it scheduled path.  When this occurs, prediction data may become
  ///
  /// unreliable since the train is no longer operating in accordance to its
  ///
  /// schedule.  The rules engine for the 'countdown' clocks will remove this
  ///
  /// train from all schedule stations.
  var actualTrack: String {
    get {return _actualTrack ?? String()}
    set {_actualTrack = newValue}
  }
  /// Returns true if `actualTrack` has been explicitly set.
  var hasActualTrack: Bool {return self._actualTrack != nil}
  /// Clears the value of `actualTrack`. Subsequent reads from it will return its default value.
  mutating func clearActualTrack() {self._actualTrack = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scheduledTrack: String? = nil
  fileprivate var _actualTrack: String? = nil
}

// MARK: - Extension support defined in nyct-subway.proto.

extension TransitRealtime_FeedHeader {

  var nyctFeedHeader: NyctFeedHeader {
    get {return getExtensionValue(ext: Extensions_nyct_feed_header) ?? NyctFeedHeader()}
    set {setExtensionValue(ext: Extensions_nyct_feed_header, value: newValue)}
  }
  /// Returns true if extension `Extensions_nyct_feed_header`
  /// has been explicitly set.
  var hasNyctFeedHeader: Bool {
    return hasExtensionValue(ext: Extensions_nyct_feed_header)
  }
  /// Clears the value of extension `Extensions_nyct_feed_header`.
  /// Subsequent reads from it will return its default value.
  mutating func clearNyctFeedHeader() {
    clearExtensionValue(ext: Extensions_nyct_feed_header)
  }
}

extension TransitRealtime_TripDescriptor {

  var nyctTripDescriptor: NyctTripDescriptor {
    get {return getExtensionValue(ext: Extensions_nyct_trip_descriptor) ?? NyctTripDescriptor()}
    set {setExtensionValue(ext: Extensions_nyct_trip_descriptor, value: newValue)}
  }
  /// Returns true if extension `Extensions_nyct_trip_descriptor`
  /// has been explicitly set.
  var hasNyctTripDescriptor: Bool {
    return hasExtensionValue(ext: Extensions_nyct_trip_descriptor)
  }
  /// Clears the value of extension `Extensions_nyct_trip_descriptor`.
  /// Subsequent reads from it will return its default value.
  mutating func clearNyctTripDescriptor() {
    clearExtensionValue(ext: Extensions_nyct_trip_descriptor)
  }
}

extension TransitRealtime_TripUpdate.StopTimeUpdate {

  var nyctStopTimeUpdate: NyctStopTimeUpdate {
    get {return getExtensionValue(ext: Extensions_nyct_stop_time_update) ?? NyctStopTimeUpdate()}
    set {setExtensionValue(ext: Extensions_nyct_stop_time_update, value: newValue)}
  }
  /// Returns true if extension `Extensions_nyct_stop_time_update`
  /// has been explicitly set.
  var hasNyctStopTimeUpdate: Bool {
    return hasExtensionValue(ext: Extensions_nyct_stop_time_update)
  }
  /// Clears the value of extension `Extensions_nyct_stop_time_update`.
  /// Subsequent reads from it will return its default value.
  mutating func clearNyctStopTimeUpdate() {
    clearExtensionValue(ext: Extensions_nyct_stop_time_update)
  }

}

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let NyctSubway_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  Extensions_nyct_feed_header,
  Extensions_nyct_trip_descriptor,
  Extensions_nyct_stop_time_update
]

let Extensions_nyct_feed_header = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<NyctFeedHeader>, TransitRealtime_FeedHeader>(
  _protobuf_fieldNumber: 1001,
  fieldName: "nyct_feed_header"
)

let Extensions_nyct_trip_descriptor = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<NyctTripDescriptor>, TransitRealtime_TripDescriptor>(
  _protobuf_fieldNumber: 1001,
  fieldName: "nyct_trip_descriptor"
)

let Extensions_nyct_stop_time_update = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<NyctStopTimeUpdate>, TransitRealtime_TripUpdate.StopTimeUpdate>(
  _protobuf_fieldNumber: 1001,
  fieldName: "nyct_stop_time_update"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension TripReplacementPeriod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TripReplacementPeriod"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "route_id"),
    2: .standard(proto: "replacement_period"),
  ]

  fileprivate class _StorageClass {
    var _routeID: String? = nil
    var _replacementPeriod: TransitRealtime_TimeRange? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _routeID = source._routeID
      _replacementPeriod = source._replacementPeriod
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replacementPeriod, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._routeID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._replacementPeriod)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._routeID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._replacementPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: TripReplacementPeriod) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._routeID != other_storage._routeID {return false}
        if _storage._replacementPeriod != other_storage._replacementPeriod {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension NyctFeedHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NyctFeedHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nyct_subway_version"),
    2: .standard(proto: "trip_replacement_period"),
  ]

  public var isInitialized: Bool {
    if self._nyctSubwayVersion == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tripReplacementPeriod) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._nyctSubwayVersion)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.tripReplacementPeriod)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nyctSubwayVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.tripReplacementPeriod.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tripReplacementPeriod, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: NyctFeedHeader) -> Bool {
    if self._nyctSubwayVersion != other._nyctSubwayVersion {return false}
    if self.tripReplacementPeriod != other.tripReplacementPeriod {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension NyctTripDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NyctTripDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "train_id"),
    2: .standard(proto: "is_assigned"),
    3: .same(proto: "direction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._trainID)
      case 2: try decoder.decodeSingularBoolField(value: &self._isAssigned)
      case 3: try decoder.decodeSingularEnumField(value: &self._direction)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._trainID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._isAssigned {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._direction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: NyctTripDescriptor) -> Bool {
    if self._trainID != other._trainID {return false}
    if self._isAssigned != other._isAssigned {return false}
    if self._direction != other._direction {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension NyctTripDescriptor.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NORTH"),
    2: .same(proto: "EAST"),
    3: .same(proto: "SOUTH"),
    4: .same(proto: "WEST"),
  ]
}

extension NyctStopTimeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NyctStopTimeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scheduled_track"),
    2: .standard(proto: "actual_track"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._scheduledTrack)
      case 2: try decoder.decodeSingularStringField(value: &self._actualTrack)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._scheduledTrack {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._actualTrack {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: NyctStopTimeUpdate) -> Bool {
    if self._scheduledTrack != other._scheduledTrack {return false}
    if self._actualTrack != other._actualTrack {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
